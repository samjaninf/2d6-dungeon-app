@implements IDialogContentComponent<MappedRoom>
@rendermode InteractiveServer


    <div>
        <h3>Move a door</h3>
        <FluentRadioGroup Name="selectedExit" @bind-Value=@selectedExitKey @onchange=@SelectedExit_onchange Label="Select a door to move" >
            @foreach(var door in @Content!.Exits!)
            {
                <FluentRadio Value="@door.Key">@door.Key</FluentRadio>
            }
        </FluentRadioGroup>

        <div hidden="@detailsHidden">
            <FluentStack Orientation="Orientation.Vertical" VerticalGap="15" >
                <FluentSlider   Label="Move the door" 
                                Orientation="@sliderOrientation" 
                                Min="@wallMinPosition" 
                                Max="@wallMaxPosition" 
                                Step="1"
                                @bind-Value="@finalPosition"
                                @bind-Value:after="@ExitMoved"
                                >
                    <FluentIcon Value="@(new Icons.Filled.Size28.Door())" Color="@Color.Accent" Slot="thumb" />
                    @for (int i = 1; i <= wallMaxPosition; i++)
                    {
                        var aPosition = i;
                        <FluentSliderLabel Position="@aPosition">@aPosition</FluentSliderLabel>
                    }
                </FluentSlider>
                <div>
                    Position on wall: from <span>@initialPosition</span> to <span>@finalPosition</span> 
                </div> 
            </FluentStack>
        </div>
    </div>




@code {

    [Parameter]
    public required MappedRoom Content { get; set; } = default!;

    [CascadingParameter]
    public FluentDialog Dialog { get; set; } = default!;

    private Direction? selectedExitKey { get; set; } = null;
    private Direction selectedDirection { get; set; } = default!;

    private bool detailsHidden = true;

    private int initialPosition = 0;
    private int finalPosition = 0;

    private int wallMinPosition = 0;
    private int wallMaxPosition = 0;

    private Orientation sliderOrientation = Orientation.Horizontal;

    protected override void OnInitialized()
    {
        // init
    }

    private async Task SaveAsync()
    {
        Content.Exits![selectedDirection].PositionOnWall = finalPosition;
        await Dialog.CloseAsync(Content);
    }

    private void SelectedExit_onchange(ChangeEventArgs value){

        selectedDirection = (Direction)Enum.Parse(typeof(Direction), value.Value!.ToString()!);
     
        switch(Content.Exits![selectedDirection].Direction){
            case Direction.North:
            case Direction.South:
                    sliderOrientation = Orientation.Horizontal;
                    wallMaxPosition = Content.Width;

                    break;
            case Direction.East:
            case Direction.West:
                    sliderOrientation = Orientation.Vertical;
                    wallMaxPosition = Content.Height;
                    break;
        }

        initialPosition = finalPosition = Content.Exits![selectedDirection].PositionOnWall;
        wallMinPosition = 1;
        detailsHidden = false;
    }

    private void ExitMoved()
    {
        Content.Exits![selectedDirection].PositionOnWall = finalPosition;
        Dialog.TogglePrimaryActionButton(true);
    }

}
